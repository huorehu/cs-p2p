На этой неделе вам предстоит разобраться с задачей сжатия данных:

На вход программы первым параметром приходит имя файла.
Например: test.txt
Если параметров нет, то предполагается что первый параметр всё-таки равен test.txt

Вторым параметром приходит имя генерируемого файла, например test.par ("par" от слов "p2p archiver"). Если второго параметра нет, то предполагается что он равен:

<имя_входящего_файла>.par (в случае если архивируем)
<имя_входящего_файла_без_.par_в_конце> (если первый параметр заканчивается на .par)
<имя_входящего_файла>.uar (от "unarchived")
Программа на основании расширения первого имени файла вычисляет, надо ли ей архивировать или разархивировать.
Также, программа может принимать первым дополнительным параметром (смещая два вышеописанных на позиции 2 и 3) флаги:

-a - явное указание системе архивировать первый файл в второй
-u - явное указание системе разархивировать из первого файла во второй
Флаги становятся полезны, если вы не хотите по какой-либо причине пользоваться расширением .par, или сделать что-то ещё более экзотическое:

Примеры:

вызов_вашей_программы poem.txt
вызов_вашей_программы poem.txt arvhied_poem.par
вызов_вашей_программы poem.txt.par
вызов_вашей_программы poem.txt.par unarvhived_poem.txt
вызов_вашей_программы poem archived
вызов_вашей_программы -u archived unarchived
вызов_вашей_программы -a archive.par archived_twice.par
При успешной архивации программа должна выдать на консоль:

эффективность сжатия/расжатия
время сжатия
размер входящего файла
и исходящего.
Теперь про алгоритм этой недели:

разработать массив битовых последовательностей, которые не пересекаются друг с другом и позволяют однозначно определить символ
закодировать файл так, что в нём в начале будет хранится таблица ассоциаций символ-битовая последовательность, а потом уже собственно биты сжатых данных.
поначалу надо будет высчитать количество уникальных символов, а отсюда уже количество бит, например если имеем 12 уникальных символов то имеем xxxx бит, т.к. больше 8 но меньше 16
итак, если у нас файл состоит из букв А и В, то по факту можно взять всего 1 бит (0 и 1) для кодирования каждой буквы
если у нас три буквы А, В, и С, то придётся взять 2 бита
Итак, где-то глубоко в вашей программе, получается, должны сидеть функции типа:

// код возврата в виде int, 0 это ок, не 0 это не ок :)
int archive(String fileIn, String fileOut);
int unarchive(String fileIn, String fileOut);
... ну или похожие на них.

На самом деле хотелось бы получить чистые функции (т.е. которые не делают ввод-вывод), допустим:

byte[] archive(byte[] inBytes);
byte[] unarchive(byte[] inBytes);
... но это будет значить, что придётся весь файл считывать в память и в какой-то момент держать в ней все данные и входящего и исходящего файла.
Это может не сработать для файла размером 4GB (в зависимости от того, какой у вас компьютер).
